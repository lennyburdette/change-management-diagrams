_reset: &RESET
  slide: { type: HIDE }
  client: { type: DEFAULT }
  router: { type: DEFAULT }
  studio: { type: DEFAULT }
  subgraph-a: { type: DEFAULT }
  subgraph-b: { type: DEFAULT }
  rest: { type: DEFAULT }
  database: { type: DEFAULT }
  task-merge-pr: { type: DEFAULT }
  task-tests: { type: DEFAULT }
  task-checks: { type: DEFAULT }
  task-build-sdl: { type: DEFAULT }
  task-build-artifact: { type: DEFAULT }
  task-deploy: { type: DEFAULT }
  task-publish: { type: DEFAULT }
  task-timer: { type: HIDE }
  task-checks-2: { type: DEFAULT }
  task-checks-2-container: { type: HIDE }
  beta-client: { type: HIDE }
  beta-router: { type: HIDE }
  laptop: { type: HIDE }

  c-router-subgraph-a: { type: DEFAULT }
  c-router-subgraph-b: { type: DEFAULT }
  c-client-router: { type: DEFAULT }

  second-pipeline: { type: HIDE }
  first-pipeline-title: { type: HIDE }
  task2-merge-pr: { type: DEFAULT }
  task2-tests: { type: DEFAULT }
  task2-checks: { type: DEFAULT }
  task2-build-sdl: { type: DEFAULT }
  task2-build-artifact: { type: DEFAULT }
  task2-deploy: { type: DEFAULT }
  task2-publish: { type: DEFAULT }
  checks-bypass: { type: HIDE }

  hooray: { type: HIDE }
  slack: { type: HIDE }

lines:
  - id: c-client-router
    from: client
    to: router
  - id: c-router-subgraph-a
    from: router
    to: subgraph-a
  - id: c-router-subgraph-b
    from: router
    to: subgraph-b
  - id: c-subgraph-a-rest
    from: subgraph-a
    to: rest
  - id: c-subgraph-b-database
    from: subgraph-b
    to: database
  - id: c-studio-router
    from: studio
    to: router
    fromAnchor: B
    toAnchor: T
  - id: c-beta-client-beta-router
    from: beta-client
    to: beta-router
    fromAnchor: R
    toAnchor: L
  - id: c-studio-beta-router
    from: studio
    to: beta-router
    fromAnchor: B
    toAnchor: T
  - id: c-beta-router-subgraph-a
    from: beta-router
    to: subgraph-a
  - id: c-beta-router-subgraph-b
    from: beta-router
    to: subgraph-b
  - id: c-laptop-studio
    from: laptop
    to: studio

steps:
  # reset
  - states:
      slide: { type: ACTIVE, id: INTRO }
      <<: *RESET
    notes: |
      Hello everyone, thanks for coming to our presentation on Change Management
      with Apollo Federation!
  - states:
      slide: { type: ACTIVE, id: AGENDA }
    notes: |
      My name is Lenny Burdette, my pronouns are he and him, and I'm a Solutions Architect at
      Apollo. I'm going to go over some theory on change management with a unified federated graph before I
      hand it over to Mark Faga from Wayfair to talk about how they're making this work in practice.
  - states:
      slide: { type: ACTIVE, id: SCENARIOS }
    notes: |
      A federated GraphQL architecture involves several components, and changing them safely sometimes requires careful planning. Apollo's Managed federation handles some of this for you, but not everything. Let's take a look at some common scenarios and talk through the proper sequence of events.
    endSection: true

  # section 1
  - states:
      slide: { type: ACTIVE, id: BACKWARD_COMPATIBLE }
    notes: |
      Let's start with the most obvious and probably most common scenario: a backward
      compatible schema change.
  - states:
      slide: { type: HIDE }
    notes: |
      Here is the structure of our managed federation system. This talk assumes
      familiarity with Managed Federation and Apollo's tools, but here's a brief
      overview of the parts.
  - states:
      client: { type: ACTIVE }
      c-client-router: { type: ACTIVE }
      router: { type: ACTIVE }
    notes: Client applications make GraphQL requests to the router (sometimes called the gateway)
  - states:
      client: { type: DEFAULT }
      c-client-router: { type: DEFAULT }
      studio: { type: ACTIVE }
      c-studio-router: { type: ACTIVE }
    notes: |
      The router receives its schema from the schema registry in Studio using Managed Federation. The schema registry is the source of truth for all schema information and handles composing the unified schema for the query planner.
  - states:
      studio: { type: DEFAULT }
      subgraph-a: { type: ACTIVE }
      subgraph-b: { type: ACTIVE }
      c-studio-router: { type: DEFAULT }
      c-router-subgraph-a: { type: ACTIVE }
      c-router-subgraph-b: { type: ACTIVE }
    notes: The router uses the query planner to break up requests into smaller requests to your subgraphs, or domain-specific GraphQL APIs,
  - states:
      router: { type: DEFAULT }
      c-router-subgraph-a: { type: DEFAULT }
      c-router-subgraph-b: { type: DEFAULT }
      rest: { type: ACTIVE }
      database: { type: ACTIVE }
      c-subgraph-a-rest: { type: ACTIVE }
      c-subgraph-b-database: { type: ACTIVE }
    notes: Which call other APIs or query databases to resolve fields.
  - states:
      task-merge-pr: { type: COMPLETE, highlight: true }
      task-tests: { type: COMPLETE, highlight: true }
      task-checks: { type: COMPLETE, highlight: true }
      task-build-sdl: { type: COMPLETE, highlight: true }
      task-build-artifact: { type: COMPLETE, highlight: true }
      task-deploy: { type: COMPLETE, highlight: true }
      task-publish: { type: COMPLETE, highlight: true }
    notes: Our continuous integration and release pipeline consists of several steps. The steps that integrate with Apollo Studio typically use the Rover command line tool.
  - states:
      task-merge-pr: { type: DEFAULT }
      task-tests: { type: DEFAULT }
      task-checks: { type: DEFAULT }
      task-build-sdl: { type: DEFAULT }
      task-build-artifact: { type: DEFAULT }
      task-deploy: { type: DEFAULT }
      task-publish: { type: DEFAULT }

      subgraph-a: { type: DEFAULT }
      subgraph-b: { type: DEFAULT }
      rest: { type: DEFAULT }
      database: { type: DEFAULT }
      c-subgraph-a-rest: { type: DEFAULT }
      c-subgraph-b-database: { type: DEFAULT }
      slide: { type: ACTIVE, id: BACKWARD_COMPATIBLE_CODE }
    notes: |
      Let's say we're introducing a new field to our schema in the Products
      subgraph. We'll add the field to the schema, and write a resolver that
      calls our REST API for the data. After writing some tests and getting
      our colleagues to review our code, we'll merge this change to the
      Products' git repo.
  - states:
      slide: { type: HIDE }
      task-merge-pr: { type: COMPLETE, highlight: true }
    notes: |
      Now our release process starts.
  - states:
      task-merge-pr: { type: COMPLETE, highlight: false }
      task-tests: { type: COMPLETE, highlight: true }
    notes: |
      Once our code is merged, our continuous integration system will run some
      prerelease steps, like running the test suite.
  - states:
      task-tests: { type: COMPLETE, highlight: false }
      task-checks: { type: ACTIVE, highlight: true }
      studio: { type: ACTIVE }
    notes: |
      It should also use the Rover command line tool to run a Subgraph Check against the
      Schema Registry. The Subgraph Check confirms that our changes won't break existing clients and that they're compatible with other subgraphs.

  ### checks
  - states:
      studio: { type: ACTIVE, work: 'check-composition' }
    duration: 800
  - states:
      studio: { type: ACTIVE, work: 'check-operations' }
    duration: 800
  - states:
      studio: { type: ACTIVE, work: 'complete' }
    duration: 800
  - states:
      studio: { type: ACTIVE }
      task-checks: { type: COMPLETE, highlight: true }
    notes: |
      After tests and checks pass, we'll build the artifacts for releasing this
      change.
  ###
  - states:
      studio: { type: DEFAULT }
      task-checks: { type: COMPLETE, highlight: false }
      task-build-sdl: { type: COMPLETE, highlight: true, schema: B }
    notes: We'll generate the subgraph SDL for publishing to the schema registry.
  - states:
      task-build-sdl: { type: COMPLETE, highlight: false, schema: B }
      task-build-artifact: { type: COMPLETE, highlight: true, code: 3 }
    notes: |
      We'll also build the docker container or jar containing the code that
      we'll deploy to our servers.

      [PAUSE]

      At this point, if we practice continuous delivery, we automatically
      continue to the next steps.
  - states:
      task-build-artifact: { type: COMPLETE, highlight: false, code: 3 }
      task-deploy: { type: ACTIVE }
    notes: |
      We'll first deploy our subgraphs with the new
      schema and code.

  ### deploy subgraph
  - states:
      subgraph-a: { type: ROLLING_DEPLOY, servers: [{ code: 3, schema: 'B' }] }
    duration: 800
  - states:
      subgraph-a:
        { type: ROLLING_DEPLOY, servers: [{ code: 3, schema: 'B' }, { code: 3, schema: 'B' }] }
    notes: |
      As the subgraph replicas roll out, we're now in various inconsistent states.
      Briefly our subgraphs don't have the same schema.
  - states:
      subgraph-a:
        {
          type: ROLLING_DEPLOY,
          servers: [{ code: 3, schema: 'B' }, { code: 3, schema: 'B' }, { code: 3, schema: 'B' }]
        }
    notes: And after rollout completes, the subgraphs and the router disagree on the schema.
  ###

  - states:
      subgraph-a: { type: DEPLOY, code: 3, schema: B }
      c-client-router: { type: BROKEN }
      client: { type: ACTIVE }
    notes: |
      If a client made a request containing the new field during this
      time, some part of the system would reject it.

      But that's ok! Remember that GraphQL's declarative query language requires
      that clients specify exactly fields that they need, and they won't get
      anything they don't ask for. We haven't updated our client apps to use the
      new field, so this is not a situation we encounter in practice. Mark put it
      a clever way a while back: "It's not like clients are polling your GraphQL
      introspection response looking for new fields to immediately call." This
      wasn't intuitive to me at first, but hopefully it makes sense to you now.

      So with that in mind, we'll continue with our release process.
  - states:
      c-client-router: { type: DEFAULT }
      client: { type: DEFAULT }
      task-deploy: { type: COMPLETE }
  - states:
      task-publish: { type: ACTIVE }
    notes: |
      Once our subgraph replicas have rolled out, the release process continues
      and we publish the subgraph schema to Apollo Studio.

  ### compose and launch
  - states:
      studio: { type: ACTIVE, work: compose }
    duration: 400
    notes: |
      Studio composes a new supergraph and delivers it to the routers.
      This is called a "Launch" in Studio, and once it's complete, we can
      announce our new schema to client teams so they can update their operations.
  - states:
      studio: { type: ACTIVE, work: compose-diagram, a: B, b: X }
    duration: 1200
  - states:
      studio: { type: ACTIVE, work: complete }
    duration: 800
  - states:
      task-publish: { type: COMPLETE }
      studio: { type: DEFAULT }
      router: { type: DEPLOY, code: 1, schema: BX, active: true }
    duration: 800
  - states:
      router: { type: DEPLOY, code: 1, schema: BX }
      client: { type: ACTIVE }
    notes: |
      If we have Schema Change notifications enabled, maybe they're
      getting a Slack notification automatically!
  - states:
      slack: { type: ACTIVE }
    notes: |
      And now we've released our change. Hooray!
  - states:
      hooray: { type: ACTIVE }

  # section 1.5 - not continuous delivery
  - states:
      slack: { type: HIDE }
      hooray: { type: HIDE }
      task-deploy: { type: DEFAULT }
      task-publish: { type: DEFAULT }
      studio: { type: DEFAULT }
      router: { type: DEFAULT }
      subgraph-a: { type: DEFAULT }
      client: { type: DEFAULT }
    notes: |
      It's worth going back a couple steps and considering what's different if we do not
      practice continuous delivery, and instead trigger deployments manually
      or as part of a release train.
  - states:
      task-timer: { type: DEFAULT }
    notes: |
      In this case, some time may pass between generating deployment artifacts
      and actually releasing our new code and schema.
  - states:
      task-checks-2-container: { type: DEFAULT }
      task-checks-2: { type: DEFAULT }
    notes: |
      We'll want to run Schema Checks again before deploying and publishing to
      make sure another team hasn't released a subgraph change that's
      incompatible with our change.

      But otherwise it's the same.
    endSection: true

  # section 2 - backwards incompatible
  - states:
      slide: { type: ACTIVE, id: BACKWARD_INCOMPATIBLE }
      <<: *RESET
    notes: |
      Now let's consider another common scenario: a backward-incompatible
      change. It's pretty much the same process, but let's go through it again
      and talk about the nuances.
  - states:
      slide: { type: ACTIVE, id: BACKWARD_INCOMPATIBLE_CODE }
    notes: |
      Let's say we're removing a field from the Products schema.
  - states:
      slide: { type: HIDE }
      task-merge-pr: { type: COMPLETE }
    notes: We've merged our pull request and the release process starts.
  - states:
      task-tests: { type: COMPLETE }
    notes: |
      Tests and checks run, we build our artifacts...
  - states:
      task-checks: { type: COMPLETE }
    duration: 400
  - states:
      task-build-sdl: { type: COMPLETE, schema: B }
    duration: 400
  - states:
      task-build-artifact: { type: COMPLETE, code: 3 }
    duration: 1200
  - states:
      task-deploy: { type: ACTIVE }
      subgraph-a: { type: ROLLING_DEPLOY, servers: [{ code: 3, schema: 'B' }] }
    duration: 800
    notes: |
      and the deployment of our subgraph code starts.
  - states:
      subgraph-a:
        { type: ROLLING_DEPLOY, servers: [{ code: 3, schema: 'B' }, { code: 3, schema: 'B' }] }
    duration: 800
  - states:
      subgraph-a:
        {
          type: ROLLING_DEPLOY,
          servers: [{ code: 3, schema: 'B' }, { code: 3, schema: 'B' }, { code: 3, schema: 'B' }]
        }
    notes: |
      We're again in an inconsistent state, where the subgraphs' schema no longer contains the field but the router's supergraph schema does.
  - states:
      subgraph-a: { type: DEPLOY, code: 3, schema: B }
      client: { type: ACTIVE }
      c-client-router: { type: ACTIVE }
      c-router-subgraph-a: { type: BROKEN }
    notes: |
      If a client makes an operation containing the removed field, in this case the router will allow it, sending a request to the Products subgraph, which will then respond with an error. This may cause the entire request to fail.

      But wait! Why are we removing a field that's actively being used?!
  - states:
      client: { type: DEFAULT }
      c-client-router: { type: DEFAULT }
      c-router-subgraph-a: { type: DEFAULT }
      slide: { type: ACTIVE, id: ADD_DEPRECATION }
    notes: |
      Before we make any breaking change, we should go through the deprecation process. We start by adding the deprecated directive to our schema, informing clients that this field should no longer be relied on.
  - states:
      slide: { type: ACTIVE, id: FIELD_USAGE }
    notes: |
      We'll then use Apollo's field usage information to observe when usage drops to zero or some acceptable level. Apollo lets us know which clients are using the field, so we can reach out to inform them about the deprecation.
  - states:
      slide: { type: HIDE }
      client: { type: ACTIVE }
    notes: |
      Now that we've update our clients to remove the field, we can perform our release. The fact that our system may be inconsistent for a period of time is not a problem, because clients can no longer trigger the failure scenario we covered a moment ago.
  - states:
      client: { type: DEFAULT }
      task-checks: { type: ACTIVE }
      task-build-sdl: { type: DEFAULT }
      task-build-artifact: { type: DEFAULT }
      task-deploy: { type: DEFAULT }
      subgraph-a: { type: DEFAULT }
    duration: 800
    notes: |
      If we couldn't get field usage to zero, but we know that the clients using the field are unsupported, our Subgraph Check will fail at this point during CI.
  - states:
      studio: { type: ACTIVE, work: check-composition }
    duration: 800
  - states:
      studio: { type: ACTIVE, work: check-operations }
    duration: 800
  - states:
      studio: { type: ACTIVE, work: error }
      task-checks: { type: BROKEN }
  - states:
      slide: { type: ACTIVE, id: OVERRIDE_UI }
    notes: |
      We can jump into Studio to see the details about the failed check. The interface allows us to mark expected failures from unsupported clients as resolved, allowing the release to continue.
  - states:
      slide: { type: HIDE }
      task-checks: { type: COMPLETE }
      studio: { type: ACTIVE, work: complete }
  - states:
      hooray: { type: ACTIVE }
      studio: { type: DEFAULT }
    notes: |
      And now we've released our breaking change and cleaned up our API. Hooray!
    endSection: true

  # section 3 - staged releases
  - states:
      <<: *RESET
      slide: { type: ACTIVE, id: ROLLBACKS }
    notes: |
      I often get questions about performing rollbacks if we encounter problems with these deployments. But what does it mean to rollback an API change? Rolling back a field addition becomes a field removal, breaking all clients now depending on this field in their operations. This is definitely something we want to avoid!

      It's worth noting that this is why we recommend keeping subgraphs separate from underlying services. If you co-mingle schema changes with other kinds of logic and data changes and need to rollback both, you get into a very awkward situation!
  - states:
      slide: { type: ACTIVE, id: STAGED_RELEASES }
    notes: |
      Instead of rolling back our schema, a better process is to release our change in stages. After we sufficiently test new fields with preview clients, we'll have significantly more confidence in the change, and we're less likely to need rollbacks at all.

      Apollo's new "contracts" feature makes this very easy:
  - states:
      slide: { type: ACTIVE, id: TAG_DIRECTIVES }
    notes: |
      we start by "tagging" our new field to indicate that it's only intended for beta clients.
  - states:
      slide: { type: HIDE }
  - states:
      router: { type: DEFAULT, hideName: true }
      beta-router: { type: ACTIVE, hideName: true }
      c-beta-router-subgraph-a: { type: ACTIVE }
      c-beta-router-subgraph-b: { type: ACTIVE }
      c-router-subgraph-a: { type: DIMMED }
      c-router-subgraph-b: { type: DIMMED }
    notes: |
      The release process is exactly the same, but we're running two routers in our cluster. One router uses our beta schema,
  - states:
      beta-client: { type: ACTIVE }
      c-beta-client-beta-router: { type: ACTIVE }
      c-beta-router-subgraph-a: { type: DEFAULT }
      c-beta-router-subgraph-b: { type: DEFAULT }
      c-client-router: { type: DIMMED }
    notes: and serves beta clients,
  - states:
      beta-router: { type: DEFAULT, hideName: true }
      beta-client: { type: DEFAULT, hideName: true }
      c-beta-client-beta-router: { type: DEFAULT }
      c-beta-router-subgraph-a: { type: DEFAULT }
      c-beta-router-subgraph-b: { type: DEFAULT }
      c-client-router: { type: ACTIVE }
      client: { type: ACTIVE }
      router: { type: ACTIVE, hideName: true }
    notes: while the other router serves our generally-available schema for everyone else.
  - states:
      beta-client: { type: DEFAULT, hideName: true }
      c-client-router: { type: DEFAULT }
      client: { type: DEFAULT }
      router: { type: DEFAULT, hideName: true }
      c-beta-client-beta-router: { type: DEFAULT }
      task-merge-pr: { type: COMPLETE }
      task-tests: { type: COMPLETE }
      task-checks: { type: COMPLETE }
      task-build-sdl: { type: COMPLETE, schema: B }
      task-build-artifact: { type: COMPLETE, code: 3 }
      task-deploy: { type: COMPLETE }
      subgraph-a: { type: DEPLOY, code: 3, schema: B }
    notes: Our release pipeline is exactly the same up through the subgraph deploy.
  - states:
      task-publish: { type: ACTIVE }
    notes: |
      When we publish the subgraph, Apollo Studio will generate two supergraphs:
  - states:
      studio: { type: ACTIVE, work: compose }
    duration: 400
  - states:
      studio: { type: ACTIVE, work: 'compose-diagram', a: B, b: X }
    notes: |
      a beta supergraph containing the field, accessible only to beta clients through their router,
  - states:
      studio: { type: ACTIVE, work: generate-contract }
    duration: 400
  - states:
      studio: { type: ACTIVE, work: 'contract-diagram', a: BX, c: AX }
    notes: |
      and a GA supergraph still without the field.
  - states:
      studio: { type: DEFAULT }
      c-studio-router: { type: ACTIVE }
      c-studio-beta-router: { type: ACTIVE }
      router: { type: DEPLOY, code: 1, schema: AX, hideName: true }
      beta-router: { type: DEPLOY, code: 1, schema: BX, hideName: true }
      task-publish: { type: COMPLETE }
    notes: This launch updates both routers (though the generally available schema doesn't actually change),
  - states:
      c-studio-router: { type: DEFAULT }
      c-studio-beta-router: { type: DEFAULT }
      beta-client: { type: ACTIVE }
      c-beta-client-beta-router: { type: ACTIVE }
    notes: And we can start testing our new field in beta clients.
  - states:
      slide: { type: ACTIVE, id: REMOVE_TAGS }
    notes: Once we're sure the new schema and code are good to go, we can release another change removing the tag.
  - states:
      hooray: { type: ACTIVE }
    endSection: true

  # section 4 - multiple subgraphs
  - states:
      slide: { type: ACTIVE, id: MULTIPLE_SUBGRAPHS }
      <<: *RESET
    notes: |
      The last scenario I want to cover is coordinating schema changes across multiple subgraphs.
  - states:
      slide: { type: HIDE }
    notes: |
      For this talk, we'll focus on what we call the "schema shuffle", moving a field from one subgraph to another. We'll walk through this change using the Federation 1 composition model that's available today — but it's worth noting that this improves with Federation 2, which we announced early in the conference.
  - states:
      subgraph-a: { type: ACTIVE }
      subgraph-b: { type: ACTIVE }
    notes: |
      Let's say we're migrating a field from the Products subgraph to the Reviews subgraph. When planning this migration, it's important to sequence the steps so that at some point, both subgraphs are capable of resolving the field. The Products subgraph already resolves it, so we'll start with the Reviews subgraph.
  - states:
      subgraph-a: { type: DEFAULT }
      subgraph-b: { type: DEFAULT }
      second-pipeline: { type: DEFAULT }
      first-pipeline: { type: DIMMED }
      first-pipeline-title: { type: DEFAULT }
    notes: |
      Here's a second release pipeline to track these steps.
  - states:
      slide: { type: ACTIVE, id: REVIEWS_ADD }
    notes: |
      We'll add the field and the resolver to the Reviews code and merge our PR.
  - states:
      slide: { type: HIDE }
    notes: |
      The tests and checks run — but here we hit our first hiccup: the checks fail because the two subgraph schemas no longer compose.
    duration: 800
  - states:
      task2-merge-pr: { type: COMPLETE }
    duration: 800
  - states:
      task2-tests: { type: COMPLETE }
    duration: 800
  - states:
      task2-checks: { type: ACTIVE }
    duration: 800
  - states:
      studio: { type: ACTIVE, work: check-composition }
    duration: 800
  - states:
      studio: { type: ACTIVE, work: error }
      task2-checks: { type: BROKEN }
    notes: |
      We'll get an error saying that Field "Product.reviews" already exists in the schema. This is expected!
  - states:
      checks-bypass: { type: DEFAULT }
    notes: |
      To continue, we'll need to bypass the check in our CI pipeline—possibly by setting a flag on the PR that tells the pipeline to skip the check.
  - states:
      task2-checks: { type: COMPLETE }
      checks-bypass: { type: HIDE }
      studio: { type: ACTIVE, work: complete }
  - states:
      studio: { type: DEFAULT }
      task2-build-sdl: { type: COMPLETE, schema: 'Y' }
      task2-build-artifact: { type: COMPLETE, code: 4 }
    notes: |
      Now that we've gotten past the prerelease steps, the release continues as normal. We build our subgraph SDL and deployable artifacts,
  - states:
      task2-deploy: { type: ACTIVE }
      subgraph-b: { type: ROLLING_DEPLOY, servers: [{ code: 4, schema: 'Y' }] }
    duration: 600
    notes: |
      initiate a rolling deploy,
  - states:
      subgraph-b:
        { type: ROLLING_DEPLOY, servers: [{ code: 4, schema: 'Y' }, { code: 4, schema: 'Y' }] }
    duration: 600
  - states:
      subgraph-b:
        {
          type: ROLLING_DEPLOY,
          servers: [{ code: 4, schema: 'Y' }, { code: 4, schema: 'Y' }, { code: 4, schema: 'Y' }]
        }
  - states:
      task2-deploy: { type: COMPLETE }
      subgraph-b: { type: DEPLOY, code: 4, schema: 'Y' }
      task2-publish: { type: ACTIVE }
    notes: |
      and publish our subgraph schema to Apollo Studio.

  - states:
      studio: { type: ACTIVE, work: check-composition }
    duration: 800
    notes: |
      When Apollo Studio receives this subgraph SDL, the change will "fail" to compose, just as the subgraph check warned us it would, and Studio will not deliver a new supergraph to the routers.
  - states:
      studio: { type: ACTIVE, work: error }
      task2-publish: { type: COMPLETE }
    notes: |

  - states:
      c-router-subgraph-a: { type: ACTIVE }
    notes: |
      The routers will continue to use the Products subgraph to resolve the field. But the Reviews subgraph is ready and waiting to receive the traffic.
    endSection: true

  # section 4.5 - products release
  - states:
      c-router-subgraph-a: { type: DEFAULT }
      studio: { type: DEFAULT, work: error }
      second-pipeline: { type: DIMMED }
      first-pipeline: { type: DEFAULT }
      slide: { type: ACTIVE, id: PRODUCTS_REMOVE }
    notes: |
      In a separate change, we'll prepare our Products subgraph to relinquish the responsibility of resolving this field.

      We'll effectively have two versions of our Products schema. We'll remove the field from the version that we publish to the schema registry,

      but we *don't* want to remove it from the runtime schema or remove the resolver — we'll see why in a moment.
  - states:
      slide: { type: HIDE }
      task-merge-pr: { type: COMPLETE }
    duration: 500
    notes: |
      We merge our code and begin the release process.
  - states:
      task-tests: { type: COMPLETE }
    duration: 500
  - states:
      task-checks: { type: ACTIVE }
    duration: 500
    notes: |
      During the prerelease steps, the Schema Check succeeds because our two subgraphs now agree about the location of the field.
  - states:
      studio: { type: ACTIVE, work: check-composition }
    duration: 500
  - states:
      studio: { type: ACTIVE, work: check-operations }
    duration: 500
  - states:
      studio: { type: ACTIVE, work: complete }
      task-checks: { type: COMPLETE }
  - states:
      studio: { type: DEFAULT }
      task-build-sdl: { type: COMPLETE, schema: B }
    notes: |
      When building the artifacts, the publishable schema will be different from the runtime schema in the code artifact.
  - states:
      task-build-artifact: { type: COMPLETE, code: 0 }
  - states:
      task-deploy: { type: ACTIVE }
      subgraph-a: { type: ROLLING_DEPLOY, servers: [{ code: 0, schema: A }] }
    notes: As we rollout the Products code,
    duration: 800
  - states:
      subgraph-a:
        { type: ROLLING_DEPLOY, servers: [{ code: 0, schema: A }, { code: 0, schema: A }] }
  - states:
      c-router-subgraph-a: { type: ACTIVE }
    notes: |
      the router will continue to send traffic for the field to the Product service. This is why we left the resolver in place.
  - states:
      c-router-subgraph-a: { type: DEFAULT }
      subgraph-a:
        {
          type: ROLLING_DEPLOY,
          servers: [{ code: 0, schema: A }, { code: 0, schema: A }, { code: 0, schema: A }]
        }
      task-deploy: { type: COMPLETE }
  - states:
      subgraph-a: { type: DEPLOY, code: 0, schema: A }
      task-publish: { type: ACTIVE }
      studio: { type: ACTIVE, work: compose }
    notes: |
      After the rollout completes, our release system publishes the new Products subgraph SDL to Studio, which can successfully compose the subgraphs.
  - states:
      studio: { type: ACTIVE, work: compose-diagram, a: B, b: 'Y' }
    duration: 1000
  - states:
      task-publish: { type: COMPLETE }
      studio: { type: ACTIVE, work: complete }
      c-studio-router: { type: ACTIVE }
    duration: 1000
  - states:
      studio: { type: DEFAULT }
      c-studio-router: { type: DEFAULT }
      router: { type: DEPLOY, code: 1, schema: BY, active: true }
    duration: 1000
    notes: |
      The Launch succeeds and the router now resolves the field using the Reviews subgraph.
  - states:
      router: { type: DEPLOY, code: 1, schema: BY, active: false }
      c-router-subgraph-b: { type: ACTIVE }
    notes: |
      The final step is to delete the field resolver from the Products subgraph and release that change. And now we have successfully shuffled our schema.
  - states:
      c-router-subgraph-b: { type: DEFAULT }
      hooray: { type: ACTIVE }

  # 4.9 - laptop
  - states:
      # reset
      hooray: { type: HIDE }
      client: { type: DEFAULT }
      studio: { type: DEFAULT }
      rest: { type: DEFAULT }
      database: { type: DEFAULT }
      task-merge-pr: { type: DEFAULT }
      task-tests: { type: DEFAULT }
      task-checks: { type: DEFAULT }
      task-build-sdl: { type: DEFAULT }
      task-build-artifact: { type: DEFAULT }
      task-deploy: { type: DEFAULT }
      task-publish: { type: DEFAULT }
      task-timer: { type: HIDE }
      # task-checks-2: { type: DEFAULT }
      # task2-merge-pr: { type: DEFAULT }
      # task2-tests: { type: DEFAULT }
      # task2-checks: { type: DEFAULT }
      # task2-build-sdl: { type: DEFAULT }
      # task2-build-artifact: { type: DEFAULT }
      # task2-deploy: { type: DEFAULT }
      # task2-publish: { type: DEFAULT }

      first-pipeline: { type: DIMMED }

      laptop: { type: ACTIVE }
      c-laptop-studio: { type: ACTIVE }
    notes: |
      With the current version of federation, this process is a bit unwieldy. Some teams choose to simplify it by publishing the schemas from development machines or a separate git repo. As long as you make sure both subgraphs can resolve the field before publishing, this is an easy and safe approach.
  - states:
      studio: { type: ACTIVE, work: compose }
    duration: 800
  - states:
      studio: { type: ACTIVE, work: compose-diagram, a: B, b: 'Y' }
    duration: 1600
  - states:
      studio: { type: ACTIVE, work: complete }
      laptop: { type: DEFAULT }
      c-laptop-studio: { type: DEFAULT }
    duration: 800
  - states:
      studio: { type: DEFAULT }
      router: { type: DEPLOY, code: 1, schema: BY, active: true }
    duration: 800
  - states:
      router: { type: DEPLOY, code: 1, schema: BY, active: false }
      c-router-subgraph-b: { type: ACTIVE }
    notes: |
      But definitely check out the Federation 2 announcement to learn how this process will get a lot easier very soon!

  # end
  - states:
      slide: { type: ACTIVE, id: KEY_TAKEAWAYS }
    notes: |
      Before I hand it over to Mark, here are some key takeaways:
  - states:
      slide: { type: ACTIVE, id: KEY_TAKEAWAY_BULLETS }
    duration: 500
  - states:
      slide: { type: ACTIVE, id: KEY_TAKEAWAY_BULLETS, step: 1 }
    notes: |
      The temporary inconsistency that happens during a release doesn't actually matter in practice. This is a huge benefit of the declarative nature of the GraphQL query language.
  - states:
      slide: { type: ACTIVE, id: KEY_TAKEAWAY_BULLETS, step: 2 }
    notes: |
      The deprecation process, assisted by field usage information, is critical to safely making breaking changes.
  # - states:
  #     slide: { type: ACTIVE, id: KEY_TAKEAWAY_BULLETS, step: 3 }
  #   notes: |
  #     It's always preferable to isolate changes from one another. For example, try to avoid changing the client API when changing how query planning works.
  - states:
      slide: { type: ACTIVE, id: KEY_TAKEAWAY_BULLETS, step: 3 }
    notes: |
      API "rollbacks" aren't really a thing. Instead, you should release changes in stages using Contracts to prevent needing rollbacks at all.
  - states:
      slide: { type: ACTIVE, id: KEY_TAKEAWAY_BULLETS, step: 4 }
    notes: |
      And finally, check out Federation 2, which we design in large part to make changes like the ones I described safer and easier.
  - states:
      hooray: { type: ACTIVE }
    notes: |
      The processes I've covered here are the foundation of a functioning unified GraphQL system. I'll hand it over to Mark to talk about how Wayfair is extending this basic system to make it even better.
