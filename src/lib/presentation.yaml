_reset: &RESET
  slide: { type: HIDE }
  client: { type: DEFAULT }
  router: { type: DEFAULT }
  studio: { type: DEFAULT }
  subgraph-a: { type: DEFAULT }
  subgraph-b: { type: DEFAULT }
  rest: { type: DEFAULT }
  database: { type: DEFAULT }
  task-merge-pr: { type: DEFAULT }
  task-tests: { type: DEFAULT }
  task-checks: { type: DEFAULT }
  task-build-sdl: { type: DEFAULT }
  task-build-artifact: { type: DEFAULT }
  task-deploy: { type: DEFAULT }
  task-publish: { type: DEFAULT }
  task-timer: { type: HIDE }
  task-checks-2: { type: DEFAULT }
  task-checks-2-container: { type: HIDE }
  beta-client: { type: HIDE }
  beta-router: { type: HIDE }
  laptop: { type: HIDE }

  c-router-subgraph-a: { type: DEFAULT }
  c-router-subgraph-b: { type: DEFAULT }
  c-client-router: { type: DEFAULT }

  second-pipeline: { type: HIDE }
  first-pipeline-title: { type: HIDE }
  task2-merge-pr: { type: DEFAULT }
  task2-tests: { type: DEFAULT }
  task2-checks: { type: DEFAULT }
  task2-build-sdl: { type: DEFAULT }
  task2-build-artifact: { type: DEFAULT }
  task2-deploy: { type: DEFAULT }
  task2-publish: { type: DEFAULT }
  checks-bypass: { type: HIDE }

  hooray: { type: HIDE }
  slack: { type: HIDE }

lines:
  - id: c-client-router
    from: client
    to: router
  - id: c-router-subgraph-a
    from: router
    to: subgraph-a
  - id: c-router-subgraph-b
    from: router
    to: subgraph-b
  - id: c-subgraph-a-rest
    from: subgraph-a
    to: rest
  - id: c-subgraph-b-database
    from: subgraph-b
    to: database
  - id: c-studio-router
    from: studio
    to: router
    fromAnchor: B
    toAnchor: T
  - id: c-beta-client-beta-router
    from: beta-client
    to: beta-router
    fromAnchor: R
    toAnchor: L
  - id: c-studio-beta-router
    from: studio
    to: beta-router
    fromAnchor: B
    toAnchor: T
  - id: c-beta-router-subgraph-a
    from: beta-router
    to: subgraph-a
  - id: c-beta-router-subgraph-b
    from: beta-router
    to: subgraph-b
  - id: c-laptop-studio
    from: laptop
    to: studio

steps:
  # reset
  - states:
      slide: { type: ACTIVE, id: INTRO }
      <<: *RESET
    notes: |
      Welcome to the end of day 1 of GraphQL Summit! Thanks for coming to our
      presentation on Change Management with Apollo Federation
  - states:
      slide: { type: ACTIVE, id: AGENDA }
    notes: |
      My name is Lenny Burdette and I'm a Solutions Architect at Apollo. I'm
      going to go over a few change management scenarios before I had it over
      to Mark Faga from Wayfair, who will describe how they're putting these
      principles into practice to create an exceptional developer experience.
  - states:
      slide: { type: ACTIVE, id: MAKING_CHANGES }
    notes: |
      A federated GraphQL API is inherently a bit complex. It involves a few
      different layers of services, and requires coordinating changes between
      these layers. This is especially true of GraphQL schema changes which
      must be coordinated between your subgraph services and the router.

      Fortunately, Apollo provides Managed Federation in its Schema Registry to
      make this easier. Unfortunately, it doesn't do everything and making
      changes safely still requires a clear understanding of the problem and
      careful planning.

      Honestly, it took me an embarrassingly long time to really understand how
      schema changes work with Managed Federation. So I wanted to take this
      opportunity to visualize a few change management scenarios to help out
      anyone else struggling with this.
  # - states:
  #     slide: { type: ACTIVE, id: TERMS, step: 1 }
  #   notes: |
  #     A note before I start: I'm assuming you're familiar with the following
  #     concepts.

  #     [CLICK] Apollo Studio is our cloud platform and includes a schema registry.

  #     [CLICK] Managed Federation is the system that uses the schema registry to
  #     make live updates to your GraphQL API as your subgraphs change.

  #     [CLICK] The router, sometimes called the gateway, takes a single GraphQL
  #     request and breaks it into smaller requests to be fulfilled by subgraphs.

  #     [CLICK] Subgraphs are the GraphQL services you and your teams build.

  #     [CLICK] Subgraph checks and publishes are commands that use the schema
  #     registry to validate and publish new subgraph schema.s

  #     [CLICK] Rover is our Command Line tool for performing checks and publishes.

  # - states:
  #     slide: { type: ACTIVE, id: TERMS, step: 2 }
  # - states:
  #     slide: { type: ACTIVE, id: TERMS, step: 3 }
  # - states:
  #     slide: { type: ACTIVE, id: TERMS, step: 4 }
  # - states:
  #     slide: { type: ACTIVE, id: TERMS, step: 5 }
  # - states:
  #     slide: { type: ACTIVE, id: TERMS, step: 6 }
  # section 1
  - states:
      slide: { type: ACTIVE, id: BACKWARD_COMPATIBLE }
    notes: |
      Let's start with the most obvious and probably most common scenario: a backward
      compatible schema change change.
  - states:
      slide: { type: HIDE }
    notes: |
      Here is the structure of our managed federation system. This talk assumes
      familiarity with Managed Federation and Apollo's tools, but here's a brief
      overview of the parts.
  - states:
      client: { type: ACTIVE }
      c-client-router: { type: ACTIVE }
      router: { type: ACTIVE }
    notes: Client applications make GraphQL requests to the router
  - states:
      client: { type: DEFAULT }
      c-client-router: { type: DEFAULT }
      studio: { type: ACTIVE }
      c-studio-router: { type: ACTIVE }
    notes: Which receives its schema from the schema registry in Studio using Managed Federation.
  - states:
      studio: { type: DEFAULT }
      subgraph-a: { type: ACTIVE }
      subgraph-b: { type: ACTIVE }
      c-studio-router: { type: DEFAULT }
      c-router-subgraph-a: { type: ACTIVE }
      c-router-subgraph-b: { type: ACTIVE }
    notes: The router breaks that request up into smaller GraphQL requests to
      your subgraph services
  - states:
      router: { type: DEFAULT }
      c-router-subgraph-a: { type: DEFAULT }
      c-router-subgraph-b: { type: DEFAULT }
      rest: { type: ACTIVE }
      database: { type: ACTIVE }
      c-subgraph-a-rest: { type: ACTIVE }
      c-subgraph-b-database: { type: ACTIVE }
    notes: Which call other APIs or query databases to resolve fields.
  - states:
      subgraph-a: { type: DEFAULT }
      subgraph-b: { type: DEFAULT }
      rest: { type: DEFAULT }
      database: { type: DEFAULT }
      c-subgraph-a-rest: { type: DEFAULT }
      c-subgraph-b-database: { type: DEFAULT }
      slide: { type: ACTIVE, id: BACKWARD_COMPATIBLE_CODE }
    notes: |
      Let's say we're introducing a new field to our schema in the Products
      subgraph. We'll add the field to the schema, and write a resolver that
      calls our REST API for the data. After writing some tests and getting
      our colleagues to review our code, we'll merge this change to the
      Products' git repo.
  - states:
      slide: { type: HIDE }
      task-merge-pr: { type: COMPLETE, highlight: true }
    notes: |
      Now our release process starts.
  - states:
      task-merge-pr: { type: COMPLETE, highlight: false }
      task-tests: { type: COMPLETE, highlight: true }
    notes: |
      Once our code is merged, our continuous integration system will run some
      prerelease steps, like running the test suite.
  - states:
      task-tests: { type: COMPLETE, highlight: false }
      task-checks: { type: ACTIVE, highlight: true }
      studio: { type: ACTIVE }
    notes: |
      It should also use Rover to run a Subgraph Check against the
      Schema Registry. The Subgraph Check will
      confirm that our changes won't affect existing operations (which it won't
      because adding a field is backward-compatible), and that our changes are
      compatible with other subgraphs.

  ### checks
  - states:
      studio: { type: ACTIVE, work: 'check-composition' }
    duration: 800
  - states:
      studio: { type: ACTIVE, work: 'check-operations' }
    duration: 800
  - states:
      studio: { type: ACTIVE, work: 'complete' }
    duration: 800
  - states:
      studio: { type: ACTIVE }
      task-checks: { type: COMPLETE, highlight: true }
    notes: |
      After tests and checks pass, we'll build the artifacts for releasing this
      change.
  ###
  - states:
      studio: { type: DEFAULT }
      task-checks: { type: COMPLETE, highlight: false }
      task-build-sdl: { type: COMPLETE, highlight: true, schema: B }
    notes: We'll generate the subgraph SDL for publishing.
  - states:
      task-build-sdl: { type: COMPLETE, highlight: false, schema: B }
      task-build-artifact: { type: COMPLETE, highlight: true, code: 3 }
    notes: |
      We'll also build the docker container, jar, or tarball that we'll use to deploy the new
      version of our subgraph code. If we're using Kubernetes or something
      similar, we may also generate deployment manifest files.

      At this point, if we practice continuous delivery, we automatically
      continue to the next steps.
  - states:
      task-build-artifact: { type: COMPLETE, highlight: false, code: 3 }
      task-deploy: { type: ACTIVE }
    notes: |
      We'll first deploy our subgraphs with the new
      schema and code.

  ### deploy subgraph
  - states:
      subgraph-a: { type: ROLLING_DEPLOY, servers: [{ code: 3, schema: 'B' }] }
    duration: 800
  - states:
      subgraph-a:
        { type: ROLLING_DEPLOY, servers: [{ code: 3, schema: 'B' }, { code: 3, schema: 'B' }] }
    notes: |
      As the subgraph replicas roll out, we're now in various inconsistent states.
      Briefly our subgraphs don't have the same schema.
  - states:
      subgraph-a:
        {
          type: ROLLING_DEPLOY,
          servers: [{ code: 3, schema: 'B' }, { code: 3, schema: 'B' }, { code: 3, schema: 'B' }]
        }
    notes: And after rollout completes, the subgraphs and the router disagree on the schema.
  ###

  - states:
      subgraph-a: { type: DEPLOY, code: 3, schema: B }
      c-client-router: { type: BROKEN }
      client: { type: ACTIVE }
    notes: |
      If a client made a request containing the new field during this
      time, some part of the system would reject it.

      But that's ok! Remember that GraphQL's declarative query language requires
      that clients specify exactly fields that they need. We haven't announced
      to any clients that the new field is available, so there are no client
      operations that contain that field. As Mark said to me a few months ago:
        "It's not like clients are polling your GraphQL introspection response
        looking for new fields to immediately call."

      This failure scenario is not something we can easily get into.
  - states:
      c-client-router: { type: DEFAULT }
      client: { type: DEFAULT }
      task-deploy: { type: COMPLETE }
  - states:
      task-publish: { type: ACTIVE }
    notes: |
      Once our subgraph replicas have rolled out, the release process continues
      and publishes the subgraph schema to Apollo Studio.

  ### compose and launch
  - states:
      studio: { type: ACTIVE, work: compose }
    duration: 400
    notes: |
      Studio composes a new supergraph and delivers it to the routers.
      This is called a "Launch" in Studio, and once it's complete, we can
      announce our new schema to client teams so they can update their operations.
  - states:
      studio: { type: ACTIVE, work: compose-diagram, a: B, b: X }
    duration: 1200
  - states:
      studio: { type: ACTIVE, work: complete }
    duration: 800
  - states:
      task-publish: { type: COMPLETE }
      studio: { type: DEFAULT }
      router: { type: DEPLOY, code: 1, schema: BX, active: true }
    duration: 800
  - states:
      router: { type: DEPLOY, code: 1, schema: BX }
      client: { type: ACTIVE }
    notes: |
      If we have Schema Change notifications enabled, maybe they're
      getting a Slack notification automatically!
  - states:
      slack: { type: ACTIVE }
    notes: |
      And now we've released our change. Hooray!
  - states:
      hooray: { type: ACTIVE }

  # section 1.5 - not continuous delivery
  - states:
      slack: { type: HIDE }
      hooray: { type: HIDE }
      task-deploy: { type: DEFAULT }
      task-publish: { type: DEFAULT }
      studio: { type: DEFAULT }
      router: { type: DEFAULT }
      subgraph-a: { type: DEFAULT }
      client: { type: DEFAULT }
    notes: |
      It's worth going back a step and considering what happens if we do not
      practice continuous delivery, and instead trigger deployments manually
      or as part of a release train.
  - states:
      task-timer: { type: DEFAULT }
    notes: |
      In this case, some time may pass between generating deployment artifacts
      and actually releasing our new code and schema.
  - states:
      task-checks-2-container: { type: DEFAULT }
      task-checks-2: { type: DEFAULT }
    notes: |
      We'll want to run Schema Checks again before deploying and publishing to
      make sure another team hasn't released a subgraph change that's
      incompatible with our change.

  # section 2 - backwards incompatible
  - states:
      slide: { type: ACTIVE, id: BACKWARD_INCOMPATIBLE }
      <<: *RESET
    notes: |
      Now let's consider another common scenario: a backward-incompatible
      change. It's pretty much the same process, but let's go through it again
      and talk about the nuances.
  - states:
      slide: { type: ACTIVE, id: BACKWARD_INCOMPATIBLE_CODE }
    notes: |
      Let's say we're removing a field from the Products schema.
  - states:
      slide: { type: HIDE }
      task-merge-pr: { type: COMPLETE }
    notes: We've merged our pull request and the release process starts.
  - states:
      task-tests: { type: COMPLETE }
    duration: 400
    notes: |
      Tests and checks run, and we build our artifacts.
  - states:
      task-checks: { type: COMPLETE }
    duration: 400
  - states:
      task-build-sdl: { type: COMPLETE, schema: B }
    duration: 400
  - states:
      task-build-artifact: { type: COMPLETE, code: 3 }
    duration: 400
  - states:
      task-deploy: { type: ACTIVE }
      subgraph-a: { type: ROLLING_DEPLOY, servers: [{ code: 3, schema: 'B' }] }
    duration: 800
    notes: |
      The deployment process for our subgraph code starts. We're again in an inconsistent state, where the subgraphs' schema no longer contains the field but the router's supergraph schema does.s
  - states:
      subgraph-a:
        { type: ROLLING_DEPLOY, servers: [{ code: 3, schema: 'B' }, { code: 3, schema: 'B' }] }
    duration: 800
  - states:
      subgraph-a:
        {
          type: ROLLING_DEPLOY,
          servers: [{ code: 3, schema: 'B' }, { code: 3, schema: 'B' }, { code: 3, schema: 'B' }]
        }
  - states:
      subgraph-a: { type: DEPLOY, code: 3, schema: B }
      c-router-subgraph-a: { type: BROKEN }
    notes: |
      If a client makes an operation containing the removed field, in this case the router will allow it, sending a request to the Products subgraph, which will then respond with an error. This may cause the entire request to fail.

      But! Why are we removing a field that's actively being used?!
  - states:
      c-router-subgraph-a: { type: DEFAULT }
      slide: { type: ACTIVE, id: ADD_DEPRECATION }
    notes: |
      [REWRITE] Before we make any backward-incompatible change, we should go through the entire deprecation process, observe field usage, and only make the change after field usage has dropped to an acceptable level. With Apollo Studio's field usage reporting, we know how often this field is used, by which clients, and in which operations.
  - states:
      slide: { type: ACTIVE, id: FIELD_USAGE }
  - states:
      slide: { type: HIDE }
      client: { type: ACTIVE }
  - states:
      client: { type: DEFAULT }
      task-checks: { type: ACTIVE }
      task-build-sdl: { type: DEFAULT }
      task-build-artifact: { type: DEFAULT }
      task-deploy: { type: DEFAULT }
      subgraph-a: { type: DEFAULT }
    duration: 800
  - states:
      studio: { type: ACTIVE, work: check-composition }
    duration: 800
  - states:
      studio: { type: ACTIVE, work: check-operations }
    duration: 800
  - states:
      studio: { type: ACTIVE, work: error }
      task-checks: { type: BROKEN }
    notes: |
      [REWRITE] During the Schema Check step of the release process, if we are receiving operations from deprecated clients that we intend to break,
  - states:
      slide: { type: ACTIVE, id: OVERRIDE_UI }
    notes: |
      we'll need to override the Operation Check in Studio before the release can continue. Studio's UI makes this very easy.
  - states:
      slide: { type: HIDE }
      task-checks: { type: COMPLETE }
      studio: { type: ACTIVE, work: complete }
  - states:
      hooray: { type: ACTIVE }
      studio: { type: DEFAULT }
    notes: |
      And now we've released our backwards-incompatible change and performed some garbage collection on our API. Hooray!

  # section 3 - staged releases
  - states:
      <<: *RESET
      slide: { type: ACTIVE, id: ROLLBACKS }
    notes: |
      I often get questions about performing a rollback if we encounter problems with these deployments. But what does it mean to rollback an API change? Rolling back a field addition becomes a backward-incompatible change, breaking all clients now depending on this field in their operations. Definitely something we want to avoid!

      (As an aside, this is one of the reasons why we suggest keeping subgraphs separate from  underlying services — if you co-mingle schema changes with other kinds of logic and data changes and need to rollback both, you get into a very awkward situation!)
  - states:
      slide: { type: ACTIVE, id: STAGED_RELEASES }
    notes: |
      Instead of rolling back our schema, a better process is to release our changes in stages, like alpha, beta, and generally available. After we sufficiently test new fields with preview clients, we'll have significantly more confidence in the change before releasing it to everyone.
  - states:
      slide: { type: ACTIVE, id: TAG_DIRECTIVES }
    notes: |
      Apollo's "contracts" feature makes this very easy: simply "tag" our new field to indicate that it's only intended for beta clients.
  - states:
      slide: { type: HIDE }
  - states:
      beta-router: { type: ACTIVE }
      c-beta-router-subgraph-a: { type: ACTIVE }
      c-beta-router-subgraph-b: { type: ACTIVE }
      c-router-subgraph-a: { type: DIMMED }
      c-router-subgraph-b: { type: DIMMED }
    notes: |
      The release process is exactly the same, but we're running two routers in our cluster.
  - states:
      beta-router: { type: DEFAULT }
      beta-client: { type: ACTIVE }
      c-beta-client-beta-router: { type: ACTIVE }
      c-beta-router-subgraph-a: { type: DEFAULT }
      c-beta-router-subgraph-b: { type: DEFAULT }
      c-client-router: { type: DIMMED }
  - states:
      beta-client: { type: DEFAULT }
      c-beta-client-beta-router: { type: DEFAULT }
      task-merge-pr: { type: COMPLETE }
      task-tests: { type: COMPLETE }
      task-checks: { type: COMPLETE }
      task-build-sdl: { type: COMPLETE, schema: B }
      task-build-artifact: { type: COMPLETE, code: 3 }
      task-deploy: { type: COMPLETE }
      subgraph-a: { type: DEPLOY, code: 3, schema: B }
  - states:
      task-publish: { type: ACTIVE }
    notes: |
      When we publish the subgraph, Apollo Studio will generate two supergraphs:
  - states:
      studio: { type: ACTIVE, work: compose }
    duration: 400
  - states:
      studio: { type: ACTIVE, work: 'compose-diagram', a: B, b: X }
    notes: |
      [REWRITE] a beta supergraph containing the field, accessible only to beta clients through their router,
  - states:
      studio: { type: ACTIVE, work: generate-contract }
    duration: 400
  - states:
      studio: { type: ACTIVE, work: 'contract-diagram', a: BX, c: AX }
    notes: |
      and a GA supergraph still without the field.
  - states:
      studio: { type: ACTIVE, work: complete }
  - states:
      studio: { type: DEFAULT }
      router: { type: DEPLOY, code: 1, schema: AX }
  - states:
      beta-router: { type: DEPLOY, code: 1, schema: BX }
  - states:
      beta-client: { type: ACTIVE }
    notes: |
      [REWRITE] Once we're sure the new schema and code are good to go, we can release another change removing the tag.
  - states:
      slide: { type: ACTIVE, id: REMOVE_TAGS }
  - states:
      hooray: { type: ACTIVE }

  # section 4 - multiple subgraphs
  - states:
      slide: { type: ACTIVE, id: MULTIPLE_SUBGRAPHS }
      <<: *RESET
    notes: |
      The last scenario I want to cover is coordinating schema changes across multiple subgraphs. There are a few reasons you might need to change multiple subgraph schemas together. Some of those reasons, like keeping an Enum type in sync, will get significantly easier with Federation 2, which we announced earlier today.
  - states:
      slide: { type: HIDE }
    notes: |
      For this talk, we'll focus on what we call the "schema shuffle", moving a field from one subgraph to another. We'll walk through this change using the Federation 1 composition model that's available today.

      One important note about this change: the GraphQL API that our client apps use does not change. Instead, only the metadata used for federation query planning changes. It's always a good idea to isolate API changes from query planning changes.
  - states:
      second-pipeline: { type: DEFAULT }
      first-pipeline: { type: DIMMED }
      first-pipeline-title: { type: DEFAULT }
    notes: |
      Let's say we're migrating a field from the Products subgraph to the Reviews subgraph. When planning this migration, it's important to sequence the steps so that at some point, both subgraphs are capable of resolving the field. The Products subgraph already resolves it, so we'll start with the Reviews subgraph. We'll need a second release pipeline to track these steps.
  - states:
      slide: { type: ACTIVE, id: REVIEWS_ADD }
    notes: |
      We'll add the field and the resolver to the Reviews code and merge our PR.
  - states:
      slide: { type: HIDE }
    notes: |
      The tests and checks run — but here we hit our first hiccup: the checks fail because the two subgraph schemas no longer compose.
    duration: 800
  - states:
      task2-merge-pr: { type: COMPLETE }
    duration: 800
  - states:
      task2-tests: { type: COMPLETE }
    duration: 800
  - states:
      task2-checks: { type: ACTIVE }
    duration: 800
  - states:
      studio: { type: ACTIVE, work: check-composition }
    duration: 800
  - states:
      studio: { type: ACTIVE, work: error }
      task2-checks: { type: BROKEN }
    notes: |
      We'll get an error saying that Field "Product.reviews" already exists in the schema. This is expected!
  - states:
      checks-bypass: { type: DEFAULT }
    notes: |
      To continue, we'll need to bypass the check in our CI pipeline—possibly by setting a flag on the PR that tells the pipeline to skip the check.
  - states:
      task2-checks: { type: COMPLETE }
      checks-bypass: { type: HIDE }
      studio: { type: ACTIVE, work: complete }
  - states:
      studio: { type: DEFAULT }
      task2-build-sdl: { type: COMPLETE, schema: 'Y' }
      task2-build-artifact: { type: COMPLETE, code: 4 }
    notes: |
      Now that we've gotten past the prerelease steps, the release continues as normal. We build our subgraph SDL and deployable artifact, initiate a rolling deploy, and publish our subgraph schema to Apollo Studio.
  - states:
      task2-deploy: { type: ACTIVE }
      subgraph-b: { type: ROLLING_DEPLOY, servers: [{ code: 4, schema: 'Y' }] }
    duration: 600
    notes: |
      - When Apollo Studio receives this subgraph SDL, the change will "fail" to compose and Studio will not deliver a new supergraph to the routers. The routers will continue to use the Products subgraph to resolve the field. But the Reviews subgraph is ready and waiting to receive the traffic.
  - states:
      subgraph-b:
        { type: ROLLING_DEPLOY, servers: [{ code: 4, schema: 'Y' }, { code: 4, schema: 'Y' }] }
    duration: 600
  - states:
      subgraph-b:
        {
          type: ROLLING_DEPLOY,
          servers: [{ code: 4, schema: 'Y' }, { code: 4, schema: 'Y' }, { code: 4, schema: 'Y' }]
        }
  - states:
      task2-deploy: { type: COMPLETE }
      subgraph-b: { type: DEPLOY, code: 4, schema: 'Y' }
      task2-publish: { type: ACTIVE }
  - states:
      studio: { type: ACTIVE, work: check-composition }
    duration: 800
  - states:
      studio: { type: ACTIVE, work: error }
      task2-publish: { type: COMPLETE }
  - states:
      c-router-subgraph-a: { type: ACTIVE }

  # section 4.5 - products release
  - states:
      c-router-subgraph-a: { type: DEFAULT }
      studio: { type: DEFAULT, work: error }
      second-pipeline: { type: DIMMED }
      first-pipeline: { type: DEFAULT }
      slide: { type: ACTIVE, id: PRODUCTS_REMOVE }
    notes: |
      In a separate change, we'll prepare our Products subgraph to relinquish the responsibility of resolving this field. In this case, we want to remove the field from the published subgraph SDL, but we *don't* want to remove it from the Products subgraph or remove the resolver — we'll discuss why in a moment. (When I talked about "building" the subgraph, this is what I mean.)
  - states:
      slide: { type: HIDE }
      task-merge-pr: { type: COMPLETE }
    duration: 500
    notes: |
      We merge our code and begin the release process.
  - states:
      task-tests: { type: COMPLETE }
    duration: 500
  - states:
      task-checks: { type: ACTIVE }
    duration: 500
    notes: |
      During the prerelease steps, the Schema Check succeeds because our two subgraphs now agree about the location of the field.
  - states:
      studio: { type: ACTIVE, work: check-composition }
    duration: 500
  - states:
      studio: { type: ACTIVE, work: check-operations }
    duration: 500
  - states:
      studio: { type: ACTIVE, work: complete }
      task-checks: { type: COMPLETE }
  - states:
      studio: { type: DEFAULT }
      task-build-sdl: { type: COMPLETE, schema: B }
    notes: |
      When building the artifacts, the publishable schema will be different from the runtime schema in the code artifact.
  - states:
      task-build-artifact: { type: COMPLETE, code: 0 }
  - states:
      task-deploy: { type: ACTIVE }
      subgraph-a: { type: ROLLING_DEPLOY, servers: [{ code: 0, schema: A }] }
  - states:
      subgraph-a:
        { type: ROLLING_DEPLOY, servers: [{ code: 0, schema: A }, { code: 0, schema: A }] }
  - states:
      c-router-subgraph-a: { type: ACTIVE }
    notes: |
      As we rollout the Products code, the router will continue to send traffic for the field to the Product service. This is why we left the resolver in place.
  - states:
      c-router-subgraph-a: { type: DEFAULT }
      subgraph-a:
        {
          type: ROLLING_DEPLOY,
          servers: [{ code: 0, schema: A }, { code: 0, schema: A }, { code: 0, schema: A }]
        }
      task-deploy: { type: COMPLETE }
  - states:
      subgraph-a: { type: DEPLOY, code: 0, schema: A }
      task-publish: { type: ACTIVE }
      studio: { type: ACTIVE, work: compose }
    notes: |
      After the rollout completes, our release system publishes the new Products subgraph SDL to Studio, which can successfully compose the subgraphs. The Launch succeeds and the router now resolves the field using the Reviews subgraph.
  - states:
      studio: { type: ACTIVE, work: compose-diagram, a: B, b: 'Y' }
  - states:
      task-publish: { type: COMPLETE }
      studio: { type: ACTIVE, work: complete }
  - states:
      studio: { type: DEFAULT }
      router: { type: DEPLOY, code: 1, schema: BY, active: true }
  - states:
      router: { type: DEPLOY, code: 1, schema: BY, active: false }
      c-router-subgraph-b: { type: ACTIVE }
  - states:
      c-router-subgraph-b: { type: DEFAULT }
      hooray: { type: ACTIVE }
    notes: |
      Once we're in a good state, we can finally delete the field resolver from the Products subgraph. We have successfully shuffled our schema.

  # 4.9 - laptop
  - states:
      # reset
      hooray: { type: HIDE }
      client: { type: DEFAULT }
      studio: { type: DEFAULT }
      rest: { type: DEFAULT }
      database: { type: DEFAULT }
      task-merge-pr: { type: DEFAULT }
      task-tests: { type: DEFAULT }
      task-checks: { type: DEFAULT }
      task-build-sdl: { type: DEFAULT }
      task-build-artifact: { type: DEFAULT }
      task-deploy: { type: DEFAULT }
      task-publish: { type: DEFAULT }
      task-timer: { type: HIDE }
      # task-checks-2: { type: DEFAULT }
      # task2-merge-pr: { type: DEFAULT }
      # task2-tests: { type: DEFAULT }
      # task2-checks: { type: DEFAULT }
      # task2-build-sdl: { type: DEFAULT }
      # task2-build-artifact: { type: DEFAULT }
      # task2-deploy: { type: DEFAULT }
      # task2-publish: { type: DEFAULT }

      first-pipeline: { type: DIMMED }

      laptop: { type: ACTIVE }
      c-laptop-studio: { type: ACTIVE }
  - states:
      studio: { type: ACTIVE, work: compose }
    duration: 800
  - states:
      studio: { type: ACTIVE, work: compose-diagram, a: B, b: 'Y' }
    duration: 1600
  - states:
      studio: { type: ACTIVE, work: complete }
      laptop: { type: DEFAULT }
      c-laptop-studio: { type: DEFAULT }
    duration: 800
  - states:
      studio: { type: DEFAULT }
      router: { type: DEPLOY, code: 1, schema: BY, active: true }
    duration: 800
  - states:
      router: { type: DEPLOY, code: 1, schema: BY, active: false }
      c-router-subgraph-b: { type: ACTIVE }

  # end
  - states:
      slide: { type: ACTIVE, id: KEY_TAKEAWAYS }
  - states:
      slide: { type: ACTIVE, id: KEY_TAKEAWAY_BULLETS }
  - states:
      slide: { type: ACTIVE, id: KEY_TAKEAWAY_BULLETS, step: 1 }
  - states:
      slide: { type: ACTIVE, id: KEY_TAKEAWAY_BULLETS, step: 2 }
  - states:
      slide: { type: ACTIVE, id: KEY_TAKEAWAY_BULLETS, step: 3 }
  - states:
      slide: { type: ACTIVE, id: KEY_TAKEAWAY_BULLETS, step: 4 }
  - states:
      slide: { type: ACTIVE, id: KEY_TAKEAWAY_BULLETS, step: 5 }
  - states:
      hooray: { type: ACTIVE }
